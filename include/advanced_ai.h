
// Advanced AI WiFi Stability Prediction System
// Generated by advanced_ai_features.py

#ifndef ADVANCED_AI_H
#define ADVANCED_AI_H

#include <Arduino.h>
#include <vector>
#include <cmath>

class AdvancedWiFiAI {
private:
    // Historical data for trend analysis
    static const int HISTORY_SIZE = 10;
    float rssi_history[HISTORY_SIZE];
    float noise_history[HISTORY_SIZE];
    float snr_history[HISTORY_SIZE];
    float util_history[HISTORY_SIZE];
    float stability_history[HISTORY_SIZE];
    int history_index = 0;
    bool history_full = false;
    
    // Advanced feature calculation methods
    float calculateMovingAverage(float* data, int size) {
        float sum = 0;
        int count = history_full ? HISTORY_SIZE : history_index;
        for (int i = 0; i < count; i++) {
            sum += data[i];
        }
        return count > 0 ? sum / count : 0;
    }
    
    float calculateVariance(float* data, int size) {
        float mean = calculateMovingAverage(data, size);
        float variance = 0;
        int count = history_full ? HISTORY_SIZE : history_index;
        for (int i = 0; i < count; i++) {
            variance += pow(data[i] - mean, 2);
        }
        return count > 1 ? variance / (count - 1) : 0;
    }
    
    float calculateTrend(float* data, int size) {
        int count = history_full ? HISTORY_SIZE : history_index;
        if (count < 3) return 0;
        
        // Simple linear regression slope
        float sum_x = 0, sum_y = 0, sum_xy = 0, sum_x2 = 0;
        for (int i = 0; i < count; i++) {
            sum_x += i;
            sum_y += data[i];
            sum_xy += i * data[i];
            sum_x2 += i * i;
        }
        
        float slope = (count * sum_xy - sum_x * sum_y) / (count * sum_x2 - sum_x * sum_x);
        return slope;
    }

public:
    AdvancedWiFiAI() {
        // Initialize history arrays
        for (int i = 0; i < HISTORY_SIZE; i++) {
            rssi_history[i] = 0;
            noise_history[i] = 0;
            snr_history[i] = 0;
            util_history[i] = 0;
            stability_history[i] = 0;
        }
    }
    
    // Advanced feature engineering
    struct AdvancedFeatures {
        // Basic features (normalized)
        float rssi_norm;
        float noise_norm;
        float snr_norm;
        float util_norm;
        
        // Derived features
        float signal_to_noise_ratio;
        float snr_to_util_ratio;
        float signal_strength_category;
        float interference_score;
        float quality_index;
        
        // Polynomial features
        float rssi_squared;
        float snr_squared;
        
        // Interaction features
        float rssi_snr_interaction;
        float noise_util_interaction;
        
        // Temporal features
        float rssi_trend;
        float noise_trend;
        float snr_trend;
        float util_trend;
        float rssi_variance;
        float noise_variance;
        
        // Stability features
        float stability_trend;
        float stability_variance;
        float is_outlier;
    };
    
    AdvancedFeatures engineerFeatures(float rssi, float noise, float snr, float channel_util) {
        AdvancedFeatures features;
        
        // Update history
        rssi_history[history_index] = rssi;
        noise_history[history_index] = noise;
        snr_history[history_index] = snr;
        util_history[history_index] = channel_util;
        
        history_index = (history_index + 1) % HISTORY_SIZE;
        if (history_index == 0) history_full = true;
        
        // Basic normalization (same as training)
        features.rssi_norm = (rssi + 90) / 30.0f;
        features.noise_norm = noise / 50.0f;
        features.snr_norm = (snr + 40) / 60.0f;
        features.util_norm = channel_util / 100.0f;
        
        // Derived features
        features.signal_to_noise_ratio = rssi / (abs(noise) + 1e-6);
        features.snr_to_util_ratio = snr / (channel_util + 1e-6);
        
        // Signal strength categorization
        if (rssi > -50) features.signal_strength_category = 3.0f;
        else if (rssi > -70) features.signal_strength_category = 2.0f;
        else if (rssi > -80) features.signal_strength_category = 1.0f;
        else features.signal_strength_category = 0.0f;
        
        features.interference_score = (abs(noise) - 95) + (channel_util / 10);
        features.quality_index = (snr * 0.4f) + ((rssi + 100) * 0.6f);
        
        // Polynomial features
        features.rssi_squared = rssi * rssi;
        features.snr_squared = snr * snr;
        
        // Interaction features
        features.rssi_snr_interaction = rssi * snr;
        features.noise_util_interaction = noise * channel_util;
        
        // Temporal features (trends and variance)
        features.rssi_trend = calculateTrend(rssi_history, HISTORY_SIZE);
        features.noise_trend = calculateTrend(noise_history, HISTORY_SIZE);
        features.snr_trend = calculateTrend(snr_history, HISTORY_SIZE);
        features.util_trend = calculateTrend(util_history, HISTORY_SIZE);
        features.rssi_variance = calculateVariance(rssi_history, HISTORY_SIZE);
        features.noise_variance = calculateVariance(noise_history, HISTORY_SIZE);
        
        // Stability temporal features
        features.stability_trend = calculateTrend(stability_history, HISTORY_SIZE);
        features.stability_variance = calculateVariance(stability_history, HISTORY_SIZE);
        
        // Outlier detection (simple threshold-based)
        features.is_outlier = 0.0f;
        if (rssi < -95 || rssi > -20 || snr < -10 || snr > 50 || channel_util > 95) {
            features.is_outlier = 1.0f;
        }
        
        return features;
    }
    
    // Advanced stability prediction with confidence
    struct PredictionResult {
        float stability;
        float confidence;
        String alert_type;
        String alert_message;
        float trend_score;
    };
    
    PredictionResult predictAdvancedStability(float rssi, float noise, float snr, float channel_util) {
        PredictionResult result;
        
        // Engineer advanced features
        AdvancedFeatures features = engineerFeatures(rssi, noise, snr, channel_util);
        
        // Advanced rule-based prediction with multiple factors
        float stability_score = 0.0f;
        float confidence = 0.0f;
        
        // Signal strength contribution (30%)
        if (rssi > -50) {
            stability_score += 0.30f;
            confidence += 0.25f;
        } else if (rssi > -70) {
            stability_score += 0.20f;
            confidence += 0.20f;
        } else if (rssi > -80) {
            stability_score += 0.10f;
            confidence += 0.15f;
        }
        
        // SNR contribution (25%)
        if (snr > 30) {
            stability_score += 0.25f;
            confidence += 0.20f;
        } else if (snr > 20) {
            stability_score += 0.18f;
            confidence += 0.15f;
        } else if (snr > 10) {
            stability_score += 0.10f;
            confidence += 0.10f;
        }
        
        // Channel utilization contribution (20%)
        if (channel_util < 30) {
            stability_score += 0.20f;
            confidence += 0.15f;
        } else if (channel_util < 60) {
            stability_score += 0.12f;
            confidence += 0.10f;
        } else if (channel_util < 80) {
            stability_score += 0.05f;
            confidence += 0.05f;
        }
        
        // Trend analysis contribution (15%)
        if (features.rssi_trend > 0 && features.snr_trend > 0) {
            stability_score += 0.15f;
            confidence += 0.15f;
        } else if (features.rssi_trend < -1 || features.snr_trend < -1) {
            stability_score -= 0.10f;
        }
        
        // Variance penalty (10%)
        if (features.rssi_variance < 5 && features.noise_variance < 3) {
            stability_score += 0.10f;
            confidence += 0.10f;
        } else if (features.rssi_variance > 15 || features.noise_variance > 8) {
            stability_score -= 0.05f;
        }
        
        // Outlier penalty
        if (features.is_outlier > 0.5f) {
            stability_score -= 0.15f;
            confidence -= 0.20f;
        }
        
        // Ensure bounds
        result.stability = constrain(stability_score, 0.0f, 1.0f);
        result.confidence = constrain(confidence, 0.0f, 1.0f);
        result.trend_score = (features.rssi_trend + features.snr_trend) / 2.0f;
        
        // Generate intelligent alerts
        generateIntelligentAlerts(features, result);
        
        // Update stability history
        stability_history[history_index == 0 ? HISTORY_SIZE - 1 : history_index - 1] = result.stability;
        
        return result;
    }
    
private:
    void generateIntelligentAlerts(const AdvancedFeatures& features, PredictionResult& result) {
        // Analyze patterns and generate specific alerts
        if (features.noise_norm > 0.8f && features.util_norm > 0.7f) {
            result.alert_type = "interference";
            result.alert_message = "Warning: High interference detected - Multiple sources competing";
        } else if (features.rssi_norm < 0.3f && features.snr_norm < 0.4f) {
            result.alert_type = "weak_signal";
            result.alert_message = "Alert: Weak signal strength - Move closer to router";
        } else if (features.rssi_trend < -0.5f) {
            result.alert_type = "degrading";
            result.alert_message = "Warning: Signal degrading - Check for obstacles";
        } else if (features.util_norm > 0.9f) {
            result.alert_type = "congestion";
            result.alert_message = "Alert: Network congestion - Consider changing channel";
        } else if (features.noise_variance > 10.0f) {
            result.alert_type = "unstable";
            result.alert_message = "Warning: Unstable environment - Intermittent interference";
        } else if (result.stability > 0.8f && result.confidence > 0.7f) {
            result.alert_type = "excellent";
            result.alert_message = "Status: Excellent connection quality";
        } else if (result.stability > 0.6f) {
            result.alert_type = "good";
            result.alert_message = "Status: Good connection quality";
        } else {
            result.alert_type = "poor";
            result.alert_message = "Warning: Poor connection quality - Multiple issues detected";
        }
    }
};

#endif // ADVANCED_AI_H
